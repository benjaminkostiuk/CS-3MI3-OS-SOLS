\documentclass[12pt, fleqn]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
\usepackage[nounderscore]{syntax}
\usepackage{mdwtab}
\usepackage{mathpartir}

\begin{document}
% \renewcommand{\texttt}[1]{\OldTexttt{\color{teal}{#1}}}
\newcommand{\pnote}[1]{{\langle \text{#1} \rangle}}
\newcommand{\mname}[1]{\mbox{\sf #1}}


% \setlength{\parindent}{0pt}
\setlength {\topmargin} {-.15in}
\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{3MI3 Assignment 2 Solution}
\author{x}
\date{\today}

\begin{center}
    {\large \textbf{COMPSCI 3MI3}}\\[8mm]
    {\huge \textbf{Assignment 2}}\\[6mm]
\end{center}

\medskip

\section{Solution Set}

\subsection{Q1}
The following EBNF grammar describes the song ``Hey Jude" as given by the diagram.

\begin{grammar}
<song> ::= <verses> \{<verses>\}

<verses> ::= `hey Jude' <v1> <v2> <v3> <v4> <v5>

<v1> ::= `don't' <c1>

<c1> ::= `make it bad take a sad song and make it better' 
        \alt  `be afraid you were made to go out and get her'
        \alt `let me down you have found here, now go and get her'

<v2> ::= `remember to' <c2>

<c2> ::= `let her into your heart' | `let her under your skin'

<v3> ::= `then you' (`can start' | `begin') `to make it better'

<v4> ::= `better better better better better waaaaa'

<v5> ::= `na' \{<v5>\} 
\end{grammar}

\subsection{Q2}

\begin{itemize}

\item The following EBNF grammar describes identifiers in Python.

\begin{grammar}
<identifier> ::= <underscore>\{<char>\} | <letter>\{<char>\}

<char> ::= <digit> | <letter> | <underscore>

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<letter> ::= <capital> | a | b | c | d | e | f | g | h | i | j | k | l | m | n\\
 | o | p | q | r | s | t | u | v | w | x | y | z | 

<capital> ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N\\
| O | P | Q | R | S | T | U | V | W | X | Y | Z

<underscore> ::= `_'
\end{grammar}

\item The following EBNF grammar describes identifiers in Haskell.

\begin{grammar}
<identifier> ::= <letter>\{<char>\} | <underscore><char>\{<char>\}

<char> ::= <digit> | <letter> | <underscore> | <single-quote>

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<letter> ::= <capital> |  a | b | c | d | e | f | g | h | i | j | k\\
 | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | 

<capital> ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N\\
| O | P | Q | R | S | T | U | V | W | X | Y | Z

<underscore> ::= `_'

<single-quote> ::= `''
\end{grammar}

\item The following EBNF grammar describes for loops in C.

Assume that statements are generated by the rule for \verb|<statement>| and expressions
by \verb|<expression>|.

\begin{grammar}

<loop> ::= for <condition> `\{' <body> `\}'

<condition> ::= `('[<statement>]`;' [<expression>]`;' [<statement>]`)'

<body> ::= \{ <statement>`;' \}

\end{grammar}

\end{itemize}

\subsection{Q3}

We define the following Python terms using inference rule style definitions shown in lecture.
For all definitions assume $\mathcal{T}$ to be the set of terms in Python.

\begin{itemize}
  \item for loop
  \begin{center}
    \begin{mathpar}
      \inferrule{
        x \in \mathcal{T}
        \and iter \in \mathcal{T}
        \and b_1 \in \mathcal {T}
        \and b_2 \in \mathcal {T}
      }
        {
          \texttt{for}\: x\: \texttt{in}\: iter \texttt{:\char`\\n\char`\\t}
          \: b_1\: \texttt{else:\char`\\n\char`\\t}\: b_2 \in \mathcal{T} 
        }
    \end{mathpar}
  \end{center}

  \item while loop
  \begin{center}
    \begin{mathpar}
      \inferrule{
        condition \in \mathcal{T}
        \and b_1 \in \mathcal {T}
        \and b_2 \in \mathcal {T}
      }
        {
          \texttt{while}\: condition \texttt{:\char`\\n\char`\\t}\:
           b_1\: \texttt{else:\char`\\n\char`\\t}\: b_2 \in \mathcal{T} 
        }
    \end{mathpar}
  \end{center}

  
  \item assignment statement
  \begin{center}
    \begin{mathpar}
      \inferrule{
        identifier \in \mathcal{T} \and expression \in \mathcal{T}
      }
      {
        identifier \: \texttt{=}\: expression \in \mathcal{T}
      }
    \end{mathpar}
  \end{center}

  \item slicing operation
  \begin{center}
    \begin{mathpar}
      \inferrule{
        x \in \mathcal{T} 
        \and start \in \mathcal{T} 
        \and end \in \mathcal{T} 
        \and step \in \mathcal{T}
      }
      {
        x \texttt{[} start \texttt{:} end \texttt{:} step \texttt{]}
      }
    \end{mathpar}
  \end{center}
  
  \item function declaration
  \begin{center}
    \begin{mathpar}
      \inferrule{
        name \in \mathcal{T} 
        \and args \in \mathcal{T}
        \and block \in \mathcal{T}
      }
      {
        \texttt{def}\: name \texttt{(}\: args \: \texttt{):\char`\\n\char`\\t}
        \: block \in \mathcal{T}
      }
    \end{mathpar}
  \end{center}




\end{itemize}

% \begin{center}
%   \begin{mathpar}
%   \texttt{true} \in \mathcal{T} 
%   \and \texttt{false} \in \mathcal{T}
%   \and \texttt{0} \in \mathcal{T} \\
%   \and \inferrule{t \in \mathcal{T}}{\texttt{succ}\: t \in \mathcal{T} \and \texttt{pred}\: t \in \mathcal{T} \and \texttt{iszero}\: t \in \mathcal{T}} \\
%   \and \inferrule{t_1 \in \mathcal{T} \and t_2 \in \mathcal{T} \and t_3 \in \mathcal{T}}{\texttt{if}\: t_1 \: \texttt{then} \: t_2 \: \texttt{else} \: t_3 \in \mathcal{T}}
%   \end{mathpar}
% \end{center}


\subsection{Q4}

\begin{enumerate}

\item[(a)] See A2\_Q4.lhs for code.

We define the syntax for Untyped Arithemtic Expressions in Haskell as follows:
\begin{verbatim}
module A2 where

data UAETerm = 
      T     -- True
    | F     -- False
    | Zero
    | IfThenElse UAETerm UAETerm UAETerm
    | Succ UAETerm
    | Pred UAETerm
    | IsZero UAETerm
    deriving (Eq, Show)
\end{verbatim}

\item[(b)] See A2\_Q4.lhs for code.

We define the following unary Haskell functions to encode the given arithmetic expressions.

\begin{verbatim}
-- (1)
exp1 :: UAETerm
exp1 = Succ $ Succ $ Succ Zero

-- (2)
exp2 :: UAETerm
exp2 = Succ $ Pred $ IsZero $ Succ T

-- (3)
exp3 :: UAETerm
exp3 = IfThenElse x y z
    where
        x = IsZero $ Succ $ Pred Zero
        y = Pred Zero
        z = Succ $ Succ $ Succ Zero
\end{verbatim}

\item[(c)]
There are semantic errors in some of the expressions from (b).

\begin{enumerate}
\item[(1)] No semantic errors.
\item[(2)] The syntactic expression $\mname{succ true}$ does not make sense semantically since $\mname{succ}$
semantically means the successor of a natural number. Thus the successor of a truth value does not make sense semantically.

Also, the sub-expression $\mname{... pred (iszero ( ...}$ also does not make sense semantically. Semantically we expect $\mname{iszero}$ to evaluate
to a truth value, checking whether its argument is equal to zero. However $\mname{pred}$ semantically evaluates to the predecessor of a natural
number. Therefore it does not makes sense to apply the predecessor to a truth value.

\item[(3)] The syntactic sub-expression $\mname{... succ (pred 0))) ...}$ does not makes sense semantically if we assume the semantics of the natural
numbers as given in the slides. We cannot take the predecessor of zero since it is the lowest natural number.

The sub-expression $\mname{(pred false)}$ in the $\mname{then}$ section of the expression does not make sense semantically since $\mname{pred}$ semantically
should evaluate to the predecessor of a natural number, and thus should not applied to a truth value like $\mname{false}$.

Overall the if-expression could have semantic errors depending on the evaluated type of $\mname{(pred false)}$ in the $\mname{then}$ expression. If it
evaluates to a boolean value the entire expression could evalute to either a truth value \emph{or} a numerical value depending if the predicate is true or false
semantically. Semantically, within a type system the expression should always evaluate to the same type.

\end{enumerate}

\end{enumerate}

\end{document}